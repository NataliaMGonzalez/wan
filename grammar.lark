// Tokens
PROGRAM: "program"
START_CONDITIONAL: "if"
ALT_CONDITIONAL: "else"
WRITE_OPERATION: "print"
READ_OPERATION: "input"
CYCLE_START: "while"

FUNCTION_DECLARE: "action"
CLASS_DECLARE: "class"
COMMENT: /#[^\n]*/
FUNCTION_RETURN: "return"

INHERITANCE: "<<"
INSTANCE_ATTRIBUTE: ":"
SELF_ATTRIBUTE: "my"
_OPEN_BLOCK: "{"
_CLOSE_BLOCK: "}"
_OPEN_GROUP: "("
_CLOSE_GROUP: ")"
_ARRAY_START: "["
_ARRAY_END: "]"
_LINE_END: ";"
_MULTIPLE: ","

BOOL_OP_AND: "&&"
BOOL_OP_OR: "||"
BOOL_OP_NE: "<>"
BOOL_OP_EQ: "=="

NEGATE: "-"

REL_OP_LT: "<"
REL_OP_GT: ">"
REL_OP_NE: "<>"
REL_OP_EQ: "=="

ASSIGNMENT: "="
ARIT_OPS_SUM: "+"
ARIT_OPS_SUBTRACT: "-"
ARIT_OPS_MULTIPLY: "*"
ARIT_OPS_DIVIDE: "/"

NEGATIVE_NUMBER: "-"

TYPE_BOOL: "bool"
TYPE_INT: "int"
TYPE_FLOAT: "float"
TYPE_CHAR: "char"
TYPE_STRING: "string"

BOOL_VALUE_TRUE: "true"
BOOL_VALUE_FALSE: "false"

INT_VALUE: /\d+/
FLOAT_VALUE: /\d+(\.\d+)?/
CHAR_VALUE: /'[^"]*'/
STRING_VALUE: /"[^"]*"/

CLASS_ID: /([A-Z][a-z0-9]+)+/
FUNCTION_ID: /\b[a-z][A-Za-z0-9]*\b/
VAR_ID: /\b[a-z_]+\b/

NEW_LINE: /\n+/
WHITESPACE: (/ / | /\t/ )+
%ignore WHITESPACE
%ignore NEW_LINE

// Rules
start: program

program: PROGRAM VAR_ID _LINE_END global_statement+

global_statement: declaration
    | assignment
    | input_output 
    | function_call
    | comment

declaration: vars_declaration
    | function_declaration
    | class_declaration

vars_declaration: declaration_type vars_declaration_id _LINE_END np_end_vars_declaration

np_end_vars_declaration:

declaration_type: TYPE_INT
    | TYPE_FLOAT
    | TYPE_CHAR
    | TYPE_BOOL
    | CLASS_ID

vars_declaration_id: VAR_ID (_ARRAY_START INT_VALUE _ARRAY_END)* [_MULTIPLE vars_declaration_id]

function_declaration: (FUNCTION_DECLARE | declaration_type) FUNCTION_ID _OPEN_GROUP [function_parameters] _CLOSE_GROUP _OPEN_BLOCK function_body _CLOSE_BLOCK np_end_function_declaration

np_end_function_declaration:

function_parameters: declaration_type VAR_ID [_MULTIPLE function_parameters]

function_body: function_statement*

function_statement: vars_declaration
    | assignment
    | function_call
    | cycle
    | conditional
    | input_output
    | comment
    | FUNCTION_RETURN expression _LINE_END

class_declaration: CLASS_DECLARE CLASS_ID [INHERITANCE CLASS_ID] _OPEN_BLOCK class_body _CLOSE_BLOCK np_end_class_declaration

np_end_class_declaration:

class_body: (vars_declaration | function_declaration | comment)+

assignment: (VAR_ID | instance_attribute | self_attribute) ASSIGNMENT expression _LINE_END

expression: or_expression

or_expression: and_expression 
    | and_expression BOOL_OP_OR and_expression

and_expression: comp_expression 
    | comp_expression BOOL_OP_AND comp_expression

comp_expression: sum_expression
    | sum_expression relop sum_expression

relop: REL_OP_LT
    | REL_OP_GT
    | REL_OP_NE
    | REL_OP_EQ

sum_expression: term 
    | term (ARIT_OPS_SUBTRACT | ARIT_OPS_SUM )term

term: factor
    | factor (ARIT_OPS_DIVIDE | ARIT_OPS_MULTIPLY) factor

factor: _OPEN_GROUP expression _CLOSE_GROUP
    | numerical_constant
    | char_exp
    | string_exp
    | bool_constant
    | function_eval 

numerical_constant: [NEGATIVE_NUMBER] (INT_VALUE | FLOAT_VALUE)

bool_constant: BOOL_VALUE_TRUE
    | BOOL_VALUE_FALSE

char_exp: CHAR_VALUE
    | var_exp

string_exp: STRING_VALUE
    | var_exp

var_exp: VAR_ID
    | instance_attribute
    | self_attribute
    | function_eval
    | _OPEN_GROUP var_exp _CLOSE_GROUP
    | var_exp (_ARRAY_START INT_VALUE _ARRAY_END)*

instance_attribute: var_exp INSTANCE_ATTRIBUTE (VAR_ID | function_eval)

self_attribute: SELF_ATTRIBUTE INSTANCE_ATTRIBUTE VAR_ID

function_call: (function_eval | var_exp) _LINE_END

function_eval: FUNCTION_ID _OPEN_GROUP arguments _CLOSE_GROUP

arguments: [expression [_MULTIPLE arguments]]

conditional: START_CONDITIONAL _OPEN_GROUP expression _CLOSE_GROUP _OPEN_BLOCK function_statement* _CLOSE_BLOCK [ALT_CONDITIONAL _OPEN_BLOCK function_statement* _CLOSE_BLOCK]

cycle: CYCLE_START _OPEN_GROUP expression _CLOSE_GROUP _OPEN_BLOCK function_statement* _CLOSE_BLOCK

input_output: read
    | write 

read: READ_OPERATION _OPEN_GROUP filename _CLOSE_GROUP _LINE_END

filename: STRING_VALUE

write: WRITE_OPERATION _OPEN_GROUP expression _CLOSE_GROUP _LINE_END

comment: COMMENT