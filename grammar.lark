// Tokens
PROGRAM: "program"
START_CONDITIONAL: "if"
ALT_CONDITIONAL: "else"
WRITE_OPERATION: "print"
READ_OPERATION: "input"
CYCLE_START: "while"

FUNCTION_DECLARE: "action"
CLASS_DECLARE: "class"
COMMENT: /#[^\n]*/
FUNCTION_RETURN: "return"

INHERITANCE: "<<"
INSTANCE_ATTRIBUTE: ":"
SELF_ATTRIBUTE: "my"
OPEN_BLOCK: "{"
CLOSE_BLOCK: "}"
OPEN_GROUP: "("
CLOSE_GROUP: ")"
ARRAY_START: "["
ARRAY_END: "]"
LINE_END: ";"
MULTIPLE: ","

BOOL_OP_AND: "&&"
BOOL_OP_OR: "||"
BOOL_OP_NE: "<>"
BOOL_OP_EQ: "=="

NEGATE: "-"

REL_OP_LT: "<"
REL_OP_GT: ">"
REL_OP_NE: "<>"
REL_OP_EQ: "=="

ASSIGNMENT: "="
ARIT_OPS_SUM: "+"
ARIT_OPS_SUBTRACT: "-"
ARIT_OPS_MULTIPLY: "*"
ARIT_OPS_DIVIDE: "/"

NEGATIVE_NUMBER: "-"

TYPE_BOOL: "bool"
TYPE_INT: "int"
TYPE_FLOAT: "float"
TYPE_CHAR: "char"
TYPE_STRING: "string"

BOOL_VALUE_TRUE: "true"
BOOL_VALUE_FALSE: "false"

INT_VALUE: /\d+/
FLOAT_VALUE: /\d+(\.\d+)?/
CHAR_VALUE: /'[^"]*'/
STRING_VALUE: /"[^"]*"/

CLASS_ID: /([A-Z][a-z0-9]+)+/
FUNCTION_ID: /\b[a-z][A-Za-z0-9]*\b/
VAR_ID: /\b[a-z_]+\b/

NEW_LINE: /\n+/
WHITESPACE: (/ / | /\t/ )+
%ignore WHITESPACE
%ignore NEW_LINE

// Rules
start: program

program: PROGRAM VAR_ID LINE_END global_statement+

global_statement: declaration
    | assignment
    | input_output 
    | function_call
    | comment

declaration: vars_declaration
    | function_declaration
    | class_declaration

vars_declaration: declaration_type vars_declaration_id LINE_END

declaration_type: TYPE_INT
    | TYPE_FLOAT
    | TYPE_CHAR
    | TYPE_BOOL
    | CLASS_ID

vars_declaration_id: VAR_ID (ARRAY_START INT_VALUE ARRAY_END)* [MULTIPLE vars_declaration_id]

function_declaration: (FUNCTION_DECLARE | declaration_type) FUNCTION_ID OPEN_GROUP function_parameters CLOSE_GROUP OPEN_BLOCK function_body CLOSE_BLOCK

function_parameters: (declaration_type VAR_ID [MULTIPLE function_parameters])*

function_body: function_statement*

function_statement: vars_declaration
    | assignment
    | function_call
    | cycle
    | conditional
    | input_output
    | comment
    | FUNCTION_RETURN expression LINE_END

class_declaration: CLASS_DECLARE CLASS_ID [INHERITANCE CLASS_ID] OPEN_BLOCK class_body CLOSE_BLOCK

class_body: (vars_declaration | function_declaration | comment)+

assignment: (VAR_ID | instance_attribute | self_attribute) ASSIGNMENT expression LINE_END

expression: or_expression

or_expression: and_expression 
    | and_expression BOOL_OP_OR and_expression

and_expression: comp_expression 
    | comp_expression BOOL_OP_AND comp_expression

comp_expression: sum_expression
    | sum_expression relop sum_expression

relop: REL_OP_LT
    | REL_OP_GT
    | REL_OP_NE
    | REL_OP_EQ

sum_expression: term 
    | term (ARIT_OPS_SUBTRACT | ARIT_OPS_SUM )term

term: factor
    | factor (ARIT_OPS_DIVIDE | ARIT_OPS_MULTIPLY) factor

factor: OPEN_GROUP expression CLOSE_GROUP
    | numerical_constant
    | char_exp
    | string_exp
    | bool_constant
    | function_eval 

numerical_constant: [NEGATIVE_NUMBER] (INT_VALUE | FLOAT_VALUE)

bool_constant: BOOL_VALUE_TRUE
    | BOOL_VALUE_FALSE

char_exp: CHAR_VALUE
    | var_exp

string_exp: STRING_VALUE
    | var_exp

var_exp: VAR_ID
    | instance_attribute
    | self_attribute
    | function_eval
    | OPEN_GROUP var_exp CLOSE_GROUP
    | var_exp (ARRAY_START INT_VALUE ARRAY_END)*

instance_attribute: var_exp INSTANCE_ATTRIBUTE (VAR_ID | function_eval)

self_attribute: SELF_ATTRIBUTE INSTANCE_ATTRIBUTE VAR_ID

function_call: (function_eval | var_exp) LINE_END

function_eval: FUNCTION_ID OPEN_GROUP arguments CLOSE_GROUP

arguments: [expression [MULTIPLE arguments]]

conditional: START_CONDITIONAL OPEN_GROUP expression CLOSE_GROUP OPEN_BLOCK function_statement* CLOSE_BLOCK [ALT_CONDITIONAL OPEN_BLOCK function_statement* CLOSE_BLOCK]

cycle: CYCLE_START OPEN_GROUP expression CLOSE_GROUP OPEN_BLOCK function_statement* CLOSE_BLOCK

input_output: read
    | write 

read: READ_OPERATION OPEN_GROUP filename CLOSE_GROUP LINE_END

filename: STRING_VALUE

write: WRITE_OPERATION OPEN_GROUP expression CLOSE_GROUP LINE_END

comment: COMMENT